"use strict";(self.webpackChunkgosc=self.webpackChunkgosc||[]).push([[4530],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=d(n),f=r,m=p["".concat(s,".").concat(f)]||p[f]||u[f]||o;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,i[1]=l;for(var d=2;d<o;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},85960:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var a=n(87462),r=(n(67294),n(3905));const o={title:"Week 8 and 9",author:"Soham Banerjee",author_url:"https://github.com/soham4abc",author_image_url:"https://avatars.githubusercontent.com/u/63705023?v=4",tags:["gsoc22","react","API"]},i=void 0,l={unversionedId:"2022/ui/updates/soham/2022-08-05",id:"2022/ui/updates/soham/2022-08-05",title:"Week 8 and 9",description:"\x3c!--",source:"@site/docs/2022/ui/updates/soham/2022-08-05.md",sourceDirName:"2022/ui/updates/soham",slug:"/2022/ui/updates/soham/2022-08-05",permalink:"/gsoc/docs/2022/ui/updates/soham/2022-08-05",draft:!1,editUrl:"https://github.com/fossology/gsoc/edit/main/docs/2022/ui/updates/soham/2022-08-05.md",tags:[{label:"gsoc22",permalink:"/gsoc/docs/tags/gsoc-22"},{label:"react",permalink:"/gsoc/docs/tags/react"},{label:"API",permalink:"/gsoc/docs/tags/api"}],version:"current",frontMatter:{title:"Week 8 and 9",author:"Soham Banerjee",author_url:"https://github.com/soham4abc",author_image_url:"https://avatars.githubusercontent.com/u/63705023?v=4",tags:["gsoc22","react","API"]},sidebar:"2022",previous:{title:"Week 6 and 7",permalink:"/gsoc/docs/2022/ui/updates/soham/2022-08-01"},next:{title:"Week 10",permalink:"/gsoc/docs/2022/ui/updates/soham/2022-08-08"}},s={},d=[{value:"<code>uploads/&lt;uploadID&gt;/licenses</code> endpoint completed",id:"uploadsuploadidlicenses-endpoint-completed",level:2},{value:"PR link - feat(api): clearing status",id:"pr-link---featapi-clearing-status",level:3},{value:"Download file using UploadID",id:"download-file-using-uploadid",level:2},{value:"PR link - feat(api): Download file using UploadID",id:"pr-link---featapi-download-file-using-uploadid",level:3},{value:"Conclusion and Further Plans",id:"conclusion-and-further-plans",level:3}],c={toc:d},p="wrapper";function u(e){let{components:t,...o}=e;return(0,r.kt)(p,(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"uploadsuploadidlicenses-endpoint-completed"},(0,r.kt)("inlineCode",{parentName:"h2"},"uploads/<uploadID>/licenses")," endpoint completed"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"(August 14th, 2022)")),(0,r.kt)("p",null,"Working on the ",(0,r.kt)("inlineCode",{parentName:"p"},"uploads/<uploadID>/licenses")," endpoint to return the latest clearing decision for each and every filepath completed this week.\nUsed ",(0,r.kt)("inlineCode",{parentName:"p"},"ItemTreeBounds")," to get the latest clearing decisions. Rather than using the seperate SQL qureies and modifications in the DAO files created seperate functions so that they can be reused and the funcionality of the earlier funtctions in the DAO files remain the same."),(0,r.kt)("p",null,"Was able to return the latest clearing status for each upload ID and return it in the api response:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"api_res",src:n(27700).Z,width:"557",height:"270"})),(0,r.kt)("p",null,"The new function created in ",(0,r.kt)("inlineCode",{parentName:"p"},"LicenseDao.php"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'public function getLicensesAndTreeIdPerFileNameForAgentId(ItemTreeBounds $itemTreeBounds,\n                                                   $selectedAgentIds=null,\n                                                   $includeSubfolders=true,\n                                                   $excluding=\'\',\n                                                   $ignore=false,\n                                                   &$clearingDecisionsForLicList = array())\n  {\n    $uploadTreeTableName = $itemTreeBounds->getUploadTreeTableName();\n    $statementName = __METHOD__ . \'.\' . $uploadTreeTableName;\n    $param = array();\n\n    $condition = " (ufile_mode & (1<<28)) = 0";\n    if ($includeSubfolders) {\n      $param[] = $itemTreeBounds->getLeft();\n      $param[] = $itemTreeBounds->getRight();\n      $condition .= " AND lft BETWEEN $1 AND $2";\n      $statementName .= ".subfolders";\n    } else {\n      $param[] = $itemTreeBounds->getItemId();\n      $condition .= " AND realparent = $1";\n    }\n\n    if (\'uploadtree_a\' == $uploadTreeTableName) {\n      $param[] = $itemTreeBounds->getUploadId();\n      $condition .= " AND upload_fk=$".count($param);\n    }\n\n    $agentSelect = "";\n    if ($selectedAgentIds !== null) {\n      $statementName .= ".".count($selectedAgentIds)."agents";\n      $agentSelect = "WHERE agent_fk IS NULL";\n      foreach ($selectedAgentIds as $selectedAgentId) {\n        $param[] = $selectedAgentId;\n        $agentSelect .= " OR agent_fk = $".count($param);\n      }\n    }\n\n    $sql = "\nSELECT uploadtree_pk, ufile_name, lft, rgt, ufile_mode,\n       rf_shortname, agent_fk\nFROM (SELECT\n        uploadtree_pk, ufile_name,\n        lft, rgt, ufile_mode, pfile_fk\n      FROM $uploadTreeTableName\n      WHERE $condition) AS subselect1\nLEFT JOIN (SELECT rf_shortname,pfile_fk,agent_fk\n           FROM license_file, license_ref\n           WHERE rf_fk = rf_pk) AS subselect2\n  ON subselect1.pfile_fk = subselect2.pfile_fk\n$agentSelect\nORDER BY lft asc\n";\n\n    $this->dbManager->prepare($statementName, $sql);\n    $result = $this->dbManager->execute($statementName, $param);\n    $licensesPerFileName = array();\n\n    $row = $this->dbManager->fetchArray($result);\n    $pathStack = array($row[\'ufile_name\']);\n    $rgtStack = array($row[\'rgt\']);\n    $lastLft = $row[\'lft\'];\n    $path = implode(\'/\', $pathStack);\n    $uploadTreeId = $row[\'uploadtree_pk\'];\n    $this->addToLicensesAndTreeIdPerFileName($licensesPerFileName, $path, $row, $ignore, $clearingDecisionsForLicList, $uploadTreeId);\n    while ($row = $this->dbManager->fetchArray($result)) {\n      if (!empty($excluding) && false!==strpos("/$row[ufile_name]/", $excluding)) {\n        $lastLft = $row[\'rgt\'] + 1;\n        continue;\n      }\n      if ($row[\'lft\'] < $lastLft) {\n        continue;\n      }\n\n      $this->updateStackState($pathStack, $rgtStack, $lastLft, $row);\n      $path = implode(\'/\', $pathStack);\n      $this->addToLicensesAndTreeIdPerFileName($licensesPerFileName, $path, $row, $ignore, $clearingDecisionsForLicList, $uploadTreeId);\n    }\n    $this->dbManager->freeResult($result);\n    return array_reverse($licensesPerFileName);\n  }\n')),(0,r.kt)("h3",{id:"pr-link---featapi-clearing-status"},"PR link - ",(0,r.kt)("a",{parentName:"h3",href:"https://github.com/fossology/fossology/pull/2288"},"feat(api): clearing status")),(0,r.kt)("h2",{id:"download-file-using-uploadid"},"Download file using UploadID"),(0,r.kt)("p",null,"Developed an API endpoint to send the file as a response for the respective ",(0,r.kt)("inlineCode",{parentName:"p"},"UploadId"),". The Api sends the file with their respective mimetype and file name which can be downloaded in the frontend.",(0,r.kt)("br",null),"\nCurrent status of the Download API response:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"api_res",src:n(72670).Z,width:"1827",height:"838"})),(0,r.kt)("h3",{id:"pr-link---featapi-download-file-using-uploadid"},"PR link - ",(0,r.kt)("a",{parentName:"h3",href:"https://github.com/fossology/fossology/pull/2309"},"feat(api): Download file using UploadID")),(0,r.kt)("h3",{id:"conclusion-and-further-plans"},"Conclusion and Further Plans"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Implementing the Import Report functionality."),(0,r.kt)("li",{parentName:"ul"},"Focussing on the Docs section and writing docs for the Final Evaluation.")))}u.isMDXComponent=!0},27700:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/api_clearing_decision-be4efb3e51aee7d6a3bb61e2714e969a.jpeg"},72670:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/download_response-1fc1fede99cfcf413d30956b7aba99e0.png"}}]);